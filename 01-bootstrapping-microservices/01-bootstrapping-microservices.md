# Bootstrapping Microservices

## Learning goals

* Initialize a new Spring Boot project
* Understande embedded servers and externalized configuration
* Package and run applications as JARs

## Overview

In this excercise, you will build a Book Service application that exposes an HTTP endpoint to return books.

* Initialize a new Spring Boot project from [Spring Initializr](https://start.spring.io) with Java 17 and Spring Web Reactive.

* Implement a method handling requests to the `/books` endpoint and returning a `Flux<String>`.

* Configure the server port to `8080`.

* Package the application as a JAR artifact and run it from the `java` CLI.

* Try different combinations of CLI arguments, JVM system properties, and environment variables to overwrite the server port value at runtime.

## Details

### Initialize a Spring Boot project

You can initialize a new Spring Boot project for **Book Service** from [Spring Initializr](https://start.spring.io).

Configure the project as follows:

* _Project_: Gradle
* _Language_: Java
* _Spring Boot_: 2.6.5+
* _Name_: book-service
* _Packaging_: JAR
* _Java_: 17+

Choose the following dependencies:

* _Spring Reactive Web (`org.springframework.boot:spring-boot-starter-webflux`)_ provides the necessary libraries for building reactive
  web applications with Spring WebFlux and includes Netty as the default embedded server.

If you prefer, you can initialize the project from the CLI.

```bash
curl https://start.spring.io/starter.zip -d groupId=com.example -d artifactId=book-service -d name=book-service -d packageName=com.example.bookservice -d dependencies=webflux -d javaVersion=17 -d bootVersion=2.6.5 -d type=gradle-project -o book-service.zip
```

Once you're done, open the project in your favourite IDE. 

### Implement an HTTP endpoint

Create a new `BookController` class to handle HTTP requests to the `/books` endpoint.

```java
@RestController
@RequestMapping("books")
class BookController {

    @GetMapping
    Flux<String> getAllBooks() {
        return Flux.just("The Lord of the Rings");
    }

}
```

The controller makes use of a few annotations:
* `@RestController` is a stereotype annotation marking a class as a Spring component and as a source of handlers
  for REST endpoints.
* `@RequestMapping` identifies the root path mapping URI for which the class provides handlers ("/books").
* `@GetMapping` maps HTTP GET requests onto the specific handler method.

### Configure the server port

Replace the autogenerated `application.properties` file with `application.yml` and configure the server port.

```yaml
server:
  port: 8080
```

### Package the application as JAR

From a Terminal window, run this command to package the Spring Boot application as a standalone JAR artifact.

```bash
$ ./gradlew bootRun
```

Then, run the application using the `java` CLI.

```bash
$ ./gradlew bootJar
```

You can now test the application works correctly.

```bash
$ http :8080/books
```

Next, experiment with the externalized configuration features provided by Spring Boot. First, use a CLI argument.

```bash
$ java -jar build/libs/book-service-0.0.1-SNAPSHOT.jar --server.port=8181
```

Then, you can try with a JVM system property.

```bash
$ java -Dserver.port=8282 -jar build/libs/book-service-0.0.1-SNAPSHOT.jar
```

Spring Boot follows specific precedence rules. If both JVM system property and CLI argument are configured, the latter takes precedence.

```bash
$ java -Dserver.port=8282 -jar build/libs/book-service-0.0.1-SNAPSHOT.jar --server.port=8181
```

Finally, configure the server port with an environment variable.

```bash
$ export SERVER_PORT=8383 && java -jar build/libs/book-service-0.0.1-SNAPSHOT.jar
```

On the Spring Boot [documentation](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config), you can find the list of property sources considered by the framework and their precedence.
